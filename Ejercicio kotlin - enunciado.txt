ğŸ§  Ejercicio prÃ¡ctico: Sistema de dispositivos inteligentes
ğŸ¯ Objetivo
Construir paso a paso un sistema de clases que simula dispositivos inteligentes del hogar, aplicando los fundamentos de la programaciÃ³n orientada a objetos en Kotlin.

âœ… Paso 1: Clase base SmartDevice
ğŸ“ Conceptos:

Clases

Constructores

Encapsulamiento con modificadores de visibilidad (private, public)

Enumeraciones (enum class)

ğŸ¤” Preguntas para pensar antes de codificar:

Â¿QuÃ© propiedades bÃ¡sicas deberÃ­a tener cualquier dispositivo inteligente?

Â¿CÃ³mo definirÃ­as su estado actual (por ejemplo, encendido o apagado)? Â¿PodrÃ­a representarse mejor con un enum?

Â¿CÃ³mo protegerÃ­as el estado interno del dispositivo para que solo pueda modificarse desde dentro de la clase?

Â¿QuÃ© diferencia hay entre turnOn() y isOn()?

ğŸ’¡ Sugerencias:

Crea una clase SmartDevice con propiedades: name, category, y deviceStatus.

Usa un enum class DeviceStatus { ON, OFF, ONLINE, OFFLINE, UNKNOWN }.

Haz deviceStatus privado.

Agrega mÃ©todos turnOn(), turnOff() y isOn(): Boolean.

ğŸ› ï¸ En Android Studio, crea un archivo llamado SmartDevice.kt en la carpeta model.

âœ… Paso 2: Subclase SmartTvDevice
ğŸ“ Conceptos:

Herencia (: SmartDevice)

Overriding

Validaciones en setters

Uso de super

ğŸ¤” Preguntas para pensar:

Â¿QuÃ© propiedades Ãºnicas tiene un televisor que no tienen otros dispositivos?

Â¿QuÃ© mÃ©todos podrÃ­as sobreescribir de SmartDevice para adaptarlos?

Â¿CÃ³mo limitarÃ­as que el volumen estÃ© entre 0 y 100? Â¿Y los canales?

ğŸ’¡ Sugerencias:

Crea una clase SmartTvDevice que herede de SmartDevice.

Agrega propiedades como volume y channel con validaciÃ³n en el set.

Sobrescribe turnOn() y turnOff() para imprimir mensajes especÃ­ficos.

Usa super.turnOn() para conservar la lÃ³gica original.

ğŸ› ï¸ Crea SmartTvDevice.kt en la misma carpeta.

âœ… Paso 3: Subclase SmartLightDevice
ğŸ“ Conceptos:

Herencia

Propiedades especÃ­ficas

Overriding

ğŸ¤” Preguntas:

Â¿QuÃ© diferencia tiene una luz inteligente respecto a una TV?

Â¿QuÃ© propiedad especÃ­fica tendrÃ­a?

Â¿DeberÃ­a comportarse igual al encender/apagar?

ğŸ’¡ Sugerencias:

Crea SmartLightDevice heredando de SmartDevice.

Agrega propiedad brightness con validaciÃ³n de 0 a 100.

Sobrescribe turnOn() para subir el brillo inicial a 2.

âœ… Paso 4: Interfaz ControllableDevice
ğŸ“ Conceptos:

Interfaces

Polimorfismo

ğŸ¤” Preguntas:

Â¿QuÃ© mÃ©todos deberÃ­an implementar todos los dispositivos controlables?

Â¿QuÃ© ventaja hay al usar una interfaz en vez de una clase base?

ğŸ’¡ Sugerencias:

Crea una interface ControllableDevice con turnOn() y turnOff().

Haz que tanto SmartTvDevice como SmartLightDevice implementen esta interfaz.

Observa cÃ³mo el polimorfismo te permite tratarlos a ambos por igual.

âœ… Paso 5: Delegado de propiedad
ğŸ“ Conceptos:

DelegaciÃ³n de propiedades

ReutilizaciÃ³n de lÃ³gica repetida (Delegates.observable)

ğŸ¤” Preguntas:

Â¿QuÃ© propiedad se repite entre dispositivos que podrÃ­as observar?

Â¿CÃ³mo podrÃ­as usar un delegado para imprimir cada vez que se cambia volume, channel o brightness?

ğŸ’¡ Sugerencias:

Usa Delegates.observable para imprimir mensajes cuando cambie el volumen, brillo o canal.

Esto mejora la trazabilidad sin meter println() en todos los set.

âœ… Paso 6: ComposiciÃ³n con clase SmartHome
ğŸ“ Conceptos:

ComposiciÃ³n

RelaciÃ³n HAS-A

ğŸ¤” Preguntas:

Â¿CÃ³mo podrÃ­as reunir todos tus dispositivos en un solo objeto?

Â¿QuÃ© ventajas tiene controlar los dispositivos desde una clase contenedora?

ğŸ’¡ Sugerencias:

Crea clase SmartHome que tenga una TV y una luz.

Agrega funciones como turnOnAllDevices(), increaseTvVolume(), etc.

MantÃ©n una propiedad devicesTurnedOn como contador.

âœ… Paso 7: CÃ³digo principal (main)
ğŸ“ Conceptos:

InstanciaciÃ³n de objetos

Uso del polimorfismo

ğŸ’¡ Sugerencias:

Crea un main.kt.

Instancia SmartTvDevice, SmartLightDevice, y SmartHome.

Prueba sus mÃ©todos y verifica sus estados.

ğŸ“š ConclusiÃ³n (al estilo del Codelab)
ğŸ” Lo que aplicaste
Encapsulamiento: Ocultaste el estado interno de los dispositivos usando private.

AbstracciÃ³n: Usaste interfaces para definir contratos de comportamiento.

Herencia: Aprovechaste cÃ³digo reutilizable en subclases.

Polimorfismo: Llamaste a los mÃ©todos turnOn() y turnOff() sin preocuparte del tipo especÃ­fico.

Delegados de propiedad: Observaste cambios en propiedades como volumen o brillo.

Modificadores de visibilidad: Controlaste el acceso a mÃ©todos y propiedades.

ğŸ“¦ Â¿DÃ³nde poner cada archivo? (Android Studio)
Archivo	Carpeta sugerida
SmartDevice.kt	app/src/main/java/.../model/
SmartTvDevice.kt	app/src/main/java/.../model/
SmartLightDevice.kt	app/src/main/java/.../model/
ControllableDevice.kt	app/src/main/java/.../interfaces/
SmartHome.kt	app/src/main/java/.../model/
Main.kt	app/src/main/java/.../ (o donde estÃ© el main de tu app Compose si es app real)